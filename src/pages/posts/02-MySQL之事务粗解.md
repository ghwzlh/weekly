---
date: 2025/01/04
---

<img src="https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/2.jpg" width="800" />

<small>人言头上发，总向愁中白。拍手笑沙鸥，一身都是愁。</small>

## 事务

你一定听说过数据库的事务四大特性分为ACID：原子性，一致性，隔离性，持久性

### 四大特性

#### 原子性

保证一个事务中的所有操作要么全部成功，要么全部失败

通过undo log回滚日志实现

#### 一致性

保证数据在事务执行前和后都保持一致，比如甲和乙的银行存款总和为1000，在甲向乙转账使用了事务，那么转账后甲和乙的银行存款总和也一定为1000

通过原子性，隔离性加上持久性来实现

#### 隔离性

数据库允许多个并发事务同时对同一数据进行更改，隔离性可以保证多个事务在同时进行更改时不会出现数据的不一致。与隔离级别有关

通过MVCC（多版本并发控制）或锁机制实现

#### 持久性

一个事务提交后，他对数据的改变是永久性的，即使数据库出问题也不会丢失改变

通过redo log（重做机制）实现



以下我们重点介绍隔离性，也就是我们为什么需要隔离性

### 并发事务带来的危害

首先，我们需要隔离性，那我们就需要知道事务并发带来的问题

MySQL客户端是允许多个客户端进行连接的，那么也就是说会出现MySQL同时处理多个事务的情况，在这个过程中会出现脏读，幻读，不可重复读等问题

#### 脏读

如果一个事务读到了另一个未提交事务修改过的数据，我们就认为发生了脏读

假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/10b513008ea35ee880c592a88adcb12f.png)

因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。

#### 幻读

在一个事务内部多次查询某个符合某一条件的记录数量，出现前后不一致，我们就认为发生了幻读

在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

举个栗子。

假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/d19a1019dc35dfe8cfe7fbff8cd97e31.png)

接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。

然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。

不可重复读

在一个事务内部，多次读取同一个数据，前后不一致，我们就认为发生了不可重复读

假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/f5b4f8f0c0adcf044b34c1f300a95abf.png)

### 事务的隔离等级

#### 并发执行事务导致的问题

前面我们知道当多个事务并发执行时可能会出现以下问题

- 脏读：读到其他未提交事务修改过的数据
- 不可重复读：在一个事务内部，多次查询某个数据出现前后不一致
- 幻读：在一个事务内部，多次查询符合某个条件的记录数量，出现前后不一致

这三个问题的严重性排序如下

脏读  >  不可重复读  >   幻读

#### 四大隔离等级

为了解决这些问题，MySQL提出了事务隔离等级，隔离等级越高，性能越差

- 读未提交：一个事务内部可以读到其他事务未提交的修改，在这种级别下，脏读，幻读，不可重复读都无法避免，所以基本不会使用这种等级的事务隔离
- 读可提交：一个事务内部可以读到其他事务提交的修改，在这种级别下，可以避免脏读，无法避免不可重复读和幻读
- 可重复读：一个事务内部针对同一数据的读取结果必须保持一致，在这种级别下，只会出现幻读
- 串行化：严格保证每个事务的执行必须串行化，也就是加锁，在这种级别下，不会出现以上三种问题，但是这种级别非常影响性能，同时MySQL的可重复读已经在很大程度上避免了幻读问题（因为就算其他事务中途插入数据对于当前事务也不可见），所以我们一般不使用。

以下举例分析四大事务等级的原理

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/yuque_mind.jpeg)

在这个情况下，四种隔离级别下分别的过程如下

1. 读未提交

事务B修改数据后，事务A就可以读取到修改后的数据（即使事务B未提交），那么结果就是v1，v2，v3都是400

1. 读提交

事务B修改数据后，由于事务隔离等级为读提交，所以在事务B提交前，事务A都无法读到修改后的值，所以v1是200，v2，v3是400

1. 可重复读

在可重复读等级下，当前事务只能看见事务启动时的数据，后序就算事务B修改数据并提交了，事务A也无法看到修改后的值，所以v1，v2都是200，v3是400

1. 串行化

在串行化等级下，在事务B要修改数据为400时，由于事务A执行了读操作，引发读写冲突，所以修改的命令会被阻塞，知道事务A提交后事务B才会继续执行，因此v1，v2都是200，v3是400

那么四种隔离等级是如何实现的呢？

- 读未提交

很显然，这种情况下只需要每次都去读取最新数据就行了

- 读已提交

通过read view实现，这种模式下会在每条语句执行时创建read view

- 可重复读

也通过read view实现，这种模式下会在每次事务启动时创建read view，整个事务都是用这个read view

- 串行化

通过加锁实现，事务的串行化执行

#### MySQL默认事务等级

MySQL默认事务等级为可重复读，他在很大程度上避免了幻读问题，他主要有以下两种办法

1. 对于快照读（selecte * from ...），通过MVCC机制实现，在可重复读等级下，事务中途的对数据的更改对于当前事务是不可见的，自然不会出现幻读问题
2. 对于当前读（select * from .... for  update），通过next_key lock（记录锁+间隙锁）实现，在执行select * from .... for  update这个语句时，会加上next_key lock，如果在中途有其他事务在next_key lock范围内插入数据，这条语句会被阻塞，无法执行插入命令

### 详解MVCC（多版本并发控制）

首先，我们要知道在MySQL中除了我们自定义的字段，还有两个隐藏字段

- trx_id
- roll_pointer

trx_id表明最新修改过该行数据的事务ID，而roll_pointer则是一个指针，指向undo log中这一行数据的旧版本，形成一条版本链。当该事务无权读到真实最新数据时，会查询这条版本链，比对事务等级，找到它有权访问的最新数据，这种通过版本链来解决并发事务访问的方法就叫MVCC

四大事务隔离等级中有两个使用了read view和MVCC

在一个事务被创建时，会生成一个read view，它包含以下内容

- min_trx_id：表示在创建read view的时刻，全局还活跃的最小的事务ID
- max_trx_id：表示在创建read view的时刻，还活跃的事务的最大ID+1
- m_ids：表示在创建read view的时刻，还活跃的所有事务的ID列表
- creator_trx_id：表示创建read view的事务ID

RR（可重复读）：

在该事务中不管语句有多少，一直使用一开始创建的read view

现在一条查询语句请求到MySQL

1. 首先会将该行数据的trx_id与min__trx_id进行比较，如果trx_id小于min_trx_id，那么说明修改数据的事务在当前事务建立之前已经提交了，说明当前事务可以看到最新数据，则返回最新数据
2. 比较trx_id与max_trx_id，如果trx_id大于等于max_trx_id，那么说明修改为这个最新数据的事务的创建时间在当前事务后，所以，当前事务是看不到最新数据，只有通过roll_pointer指针去找到有权限看到的数据返回
3. 如果trx_id的值位于min_trx_id与max_trx_id之间，则去m_ids里查找这个trx_id，如果这个值在m_ids中，说明在当前事务创建前这个修改数据的事务还没有提交，那么当前事务无法看到最新数据，只能通过roll_pointer指针找到可以看到的最新数据返回；如果这个值不在m_ids中，说明在当前事务创建之前这个修改数据的事务已经提交，那么会返回最新数据

RC（读已提交）

与上述过程类似，只是在这种隔离等级下，是每条语句都会创建read_view，而不会复用最开始的那一个read_view。

### MySQL可重复读一定程度上解决幻读

针对快照读，使用MVCC一定程度上解决幻读问题，上文提过

针对当前读，使用间隙锁（next-key-lock）在一定程度上解决

如果现在数据库中有一个id范围为（3， 5）的间隙锁，那么要插入id为4的记录就不被允许，操作会被阻塞

举个具体例子

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/3af285a8e70f4d4198318057eb955520.png)

这时在事务B执行插入语句时，由于事务A对表中的记录加上了id范围为(2, +∞]的next-key-lock（间隙锁+记录锁），因此事务B会生成一个插入意向锁，同时进入等待状态，直到事务A提交

但这种方法没有完全解决幻读问题

以下举两个例子

1. 首先事务A开始，执行以下语句

```sql
select * from t_stu where id = 5;
```

由于此时id为5的数据不存在，所以返回数据为empty

但这时事务B执行以下语句

```sql
insert into t_stu values(5, "小美", 18);
commit
```

然后事务A执行以下语句

```sql
update t_stu set name = "小红" where id = 5;
```

虽然事务A此时应该是看不到这条数据的，但他更新了这条数据，然后事务A去查询ID为5的数据就可以看到了

![img](https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/%25E5%25B9%25BB%25E8%25AF%25BB%25E5%258F%2591%25E7%2594%259F.drawio.png)

解释：

在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。



1. 除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。

- T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。
- T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
- T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。

要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。



### 如何避免长事务对业务的影响

**首先，从应用开发端来看：**

1. 确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）

**其次，从数据库端来看：**

1. 监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；
2. Percona 的 pt-kill 这个工具不错，推荐使用；
3. 在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；
4. 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。