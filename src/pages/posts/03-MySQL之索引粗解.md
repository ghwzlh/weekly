---
date: 2025/01/12
---

<img src="https://web-ghw-demo.oss-cn-hangzhou.aliyuncs.com/3-img/3-img/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91ins%E9%A3%8E-%E6%B5%B7%E8%BE%B9%E8%8D%89%E5%9C%B0.png" width="800" />

<small>待羊儿，酒罢又烹茶，扬州鹤。</small>

## 索引（InnoDB）
当我们的数据库中的数据越来越多时，查询语句的耗时会越来越长直到我们无法容忍，我们一定会想到使用索引来优化。

### 什么是索引
当你去看一本很厚的书时，要找到某段内容，一定是先去目录找到这段内容附近，然后在细细的查找，而索引就是数据库中的数据的目录，我们可以通过索引来快速的定位某个元素

### 索引的分类
+ 按数据结构分：B+ Tree索引，Hash索引，Full Text索引
+ 按物理结构分：聚簇索引（主键索引），二级索引
+ 按字段特性分：主键索引，唯一索引，普通索引，前缀索引
+ 按字段个数分：单列索引，联合索引

### 为什么InnoDB会选择B+Tree作为索引类型
分析这个问题，我们首先来看有哪些数据结构可以作为索引的存储结构

以下是一些除了B+Tree之外的可选数据结构

1. 哈希表

使用哈希表其实也是十分合适的，对于等值查找我们只需要进行哈希值的运算即可，但是使用哈希表有一个大问题，那就是不适合范围查询，毕竟原来的值可能是a大于b，但进行哈希值计算后可能就不是这样了

```sql
select a from t_table where a between 1 and 2
```

这个SQL语句，1和2的哈希值可能就不符合原来的大小关系

2. 二叉查找树

对于一颗二叉平衡树，最坏的情况可能会退变为链表，而且每个节点都存储数据，查询的效率强依赖于树的平衡程度

3. 二叉平衡树

对于一颗二叉平衡树，在插入和删除节点时，都要频繁的进行旋转操作，因此对插入数据和删除数据的性能会有影响。同时，每次IO都只能和查询一个节点的数据，如果查询的数据分布在多个节点上，就要进行多次IO，这与我们建立索引的初衷不符

4. 红黑树

红黑树是一种自平衡二叉树，在插入和删除时通过颜色变换和旋转来保证平衡

红黑树的规则如下

+ 根节点一定是黑色
+ 每个节点非黑即红
+ 每个叶子结点都是黑色的空节点
+ 如果一个节点是红色的，那么他的子节点一定是黑色（反之不一定）
+ 任意节点到任何一个子节点或空子节点的路径上，经过的黑色节点数一定都一致

但由于红黑树实现的不是严格的平衡，有可能导致树的高度会较高导致查询性能的下降

那么选择B+Tree的原因有哪些呢

+ B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
+ B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
+ B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

### 唯一索引
唯一索引的列不允许出现重复的值，但允许出现NULL

唯一索引的性能可能比不上普通索引，我们可以从两个方面解释

1. 查询
+ 普通索引：从第一个符合条件的数据开始向下查找，直到不符合条件
+ 唯一索引：只找第一个数据，因为数据不可重复
2. 更新
+ 普通索引：当数据页在内存中，直接更新，不然把操作记录在change Buffer中，在该数据页被读到内存中时执行merge操作或者由后台线程异步的区进行merge操作，由于使用了change buffer，所以性能优于唯一索引
+ 唯一索引：当数据页在内存中，进行唯一性检查，然后直接更新，不然将数据页读到内存，进行唯一性检查，然后更新

### 回表
当我们使用二级索引来查找数据时，由于二级索引的B+Tree的叶子节点中存放的是主键值（主键索引的B+Tree叶子节点存放的是对应的数据），所以当我们根据二级索引查找到主键值后，会再次根据主键值去主键索引的B+Tree中查找对应的叶子节点，这个操作我们叫做回表。也就是说我们需要查找两个B+Tree才可以查找到数据，本来需要一次IO，现在需要两次。当也有例外，就是下面的覆盖索引。

### 覆盖索引
当我们需要查找的数据只需要查找二级索引的那一颗B+Tree，不需要回表。也就是说我们要查的数据和筛选条件之间是联合索引的关系或者根据自己查找自己

现在我们有一张表，主键为ID，二级索引为Key，我们执行以下语句

```sql
select ID from T_stu where Key = 1;
```

当我们执行这行语句，我们不需要回表

### 联合索引最左匹配原则
当我们使用联合索引时，比如我们有一张表

```sql
CREATE TABLE `product`  (
  `id` int(11) NOT NULL,
  `product_no` varchar(20)  DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `price` decimal(10, 2) DEFAULT NULL,
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

现在我们建立了（a，b）这样的联合索引，那么那颗B+Tree上的节点会先按a的值进行排序，如果a的值相同再按b的值进行排序。

所以，我们在使用联合索引时，存在最左匹配原则，就是按照左优先的方式来匹配索引，如果不遵循最左匹配原则就无法使用联合索引。

以下SQL语句可以使用（a， b）这个索引

```sql
select * from product where a = 1;
select * from product where a = 1 and b > 1;
```

以下语句无法使用

```sql
select * from product where b = 1;
select * from product where b = 1 and a = 1;
```

#### 联合索引范围查询
当我们使用联合索引时并不是联合索引中的所有字段都被使用到了，有时只是联合索引中的一些字段被使用到了。

```sql
select * from t_table where a > 1 and b = 1;
```

以上语句只会使用到（a，b）联合索引中的a字段

语句在执行时，会现在B+Tree上根据a > 1这一条件进行查找，找到第一个a > 1的数据，然后一直向前查找，一直到不满足a > 1为止，那为什么b字段无法使用呢。因为在所有a > 1的数据中，b字段并不是有序的，只有在a字段相同的情况下，b字段才是有序的，也就是说，a是全局有序，b是局部有序

```sql
select * from t_table where a >= 1 and b = 1;
```
以上语句会同时使用a和b两个字段

首先，语句在执行时，会现在B+Tree上根据a >= 1这一条件进行查找，找到第一个a >= 1的数据，然后一直向前查找，一直到不满足a >= 1为止，那为什么这里b字段可以使用呢。因为在所有a > 1的数据中，b字段并不是有序的。但是，在a = 1的所有数据中，b字段是有序的

```sql
select * from t_table where a BETWEEN 1 AND 2 and b = 1;
```


以上语句会同时使用a和b两个字段

因为MySQL中的between是包含边界值的，也就是1 <= a <= 2，跟上文一样

```sql
select * from t_table where name like 'j%' and age = 22;
```

以上语句会同时使用age和name两个字段

首先，语句在执行时，会现在B+Tree上根据name like 'j%'这一条件进行查找，找到第一个符合的数据，然后一直向前查找，一直到不满足条件为止，那为什么这里age字段可以使用呢。因为在所有name = 'j'的数据中，age字段是有序的。

### 索引下推
```sql
select * from t_table where name like 'j%' and age = 22;
```

这条语句即使在已经有了（name, age）索引的情况下也会，拿到(name = 'j', age = 20)这样一条数据去回表，查询全部数据然后比较22与age的值，而不是在查找索引时直接比较age与22的值。

因此在MySQL5.6版本后，推出了索引下推优化，可以在（name, age）联合索引内部直接筛掉age不等于22的数据，减少回表次数，提高查询效率

索引下推是将原本在Server层的任务交给了存储引擎层实现。原本会依据name like "j%"查找出所有符合条件的数据再去回表查找全量数据交给Server层，在Server层进行age的筛选，而索引下推是在存储引擎内部直接依据age进行筛选

### 索引失效
+ <font style="color:rgb(62, 62, 62);">使用 SELECT * 进行查询，where后面的查询范围过大， 导致优化器可能会认为全表扫描比索引更高效。</font>
+ <font style="color:rgb(62, 62, 62);">创建了联合索引，但查询条件未遵守最左匹配原则;</font>
+ <font style="color:rgb(62, 62, 62);">在索引列上进行计算、函数、类型转换等操作;</font>
+ <font style="color:rgb(62, 62, 62);">以 % 开头的 LIKE 查询比如 like '%abc';</font>
+ <font style="color:rgb(62, 62, 62);">查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</font>
+ <font style="color:rgb(62, 62, 62);">发生了隐式转换</font>
+ <font style="color:rgb(62, 62, 62);">IN的取值范围过大，导致索引失效，会走全表扫描</font>

### <font style="color:rgba(0, 0, 0, 0.9);">为什么要限制每张表上的索引数量？</font>
索引可以提高查询效率，是不是一张表上索引越多越好呢，其实不然。索引可以提高效率也可以降低效率，因为MySQL优化器在选择如何优化SQL查询时，会对每一个索引进行评估，以生成一个最好的执行计划，如果同时有很多索引都可以使用，就会增加MySQL优化器生成执行计划的时间，同样会降低查询性能。所以一般建议单表索引不超过5个，根据实际频繁查询的字段设置索引。

